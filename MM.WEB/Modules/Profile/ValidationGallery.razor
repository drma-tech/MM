@page "/profile/validation/gallery"
@using KristofferStrube.Blazor.MediaCaptureStreams
@using KristofferStrube.Blazor.MediaCaptureStreams.Exceptions
@using KristofferStrube.Blazor.WebIDL.Exceptions
@using MM.Shared.Models.Profile
@using MM.WEB.Api
@using MM.WEB.Modules.Profile.Core
@using Microsoft.AspNetCore.Authorization
@using Microsoft.JSInterop
@attribute [Authorize]
@inherits PageCore<ValidationGallery>

@inject ValidationApi ValidationApi
@inject IMediaDevicesService MediaDevicesService;

<MudGrid Spacing="@Css.SpaceSmall" Justify="Justify.Center">
    <MudItem xs="12" sm="10" md="8" lg="6">
        <MudCard Outlined="true">
            <MudCardHeader Class="pa-2">
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">Main photo validation</MudText>
                </CardHeaderContent>
                <CardHeaderActions>
                    <MudIconButton Icon="@IconsFA.Solid.Icon("user-shield").Font" Color="Color.Default"
                                   OnClick="@(async() => await MudDialog!.ShowAsync("Privacy Terms", PopupHelper.Options(MaxWidth.ExtraSmall)))" />
                </CardHeaderActions>
            </MudCardHeader>
            <MudCardContent Class="pa-2">
                @if (videoStreamTrack is null && Picture.NotEmpty())
                {
                    <img src="data:image/png;base64,@Convert.ToBase64String(Picture)" alt="Captured Photo" width="100%" />
                }
                else if (videoStreamTrack is null)
                {
                    <div style="text-align: center;">
                        <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenVideo" Class="my-5">
                            Load Camera
                        </MudButton>
                    </div>
                }
                else
                {
                    <MudSelect Label="Camera" Disabled="Cameras.Empty()" Class="mb-2" Value="@currentCameraId" ValueChanged="@(async (string vl) => { currentCameraId = vl; await SelectDevice(vl); })">
                        @foreach (var option in Cameras)
                        {
                            <MudSelectItem Value="@option.id">
                                @option.label
                            </MudSelectItem>
                        }
                    </MudSelect>
                    <video @ref="videoElement" width="100%" autoplay></video>
                }
            </MudCardContent>
            <MudCardActions Class="pt-0">
                @if (Picture.Empty())
                {
                    <MudButton Color="Color.Primary" Variant="Variant.Filled" StartIcon="@IconsFA.Solid.Icon("camera").Font" OnClick="TakeShot" Class="me-2"
                               Disabled="@(videoStreamTrack is null)">
                        Take Shot
                    </MudButton>
                }
                else
                {
                    <MudButton Color="Color.Secondary" Variant="Variant.Filled" StartIcon="@IconsFA.Solid.Icon("rotate").Font" OnClick="Reset" Class="me-2">
                        Reset
                    </MudButton>
                }
                <MudSpacer></MudSpacer>
                <MudButton Color="Color.Primary" Variant="Variant.Filled" StartIcon="@IconsFA.Solid.Icon("share-square").Font" OnClick="SendPhoto"
                           Disabled="Picture.Empty() || Validation == null || Validation.Gallery">
                    Send
                </MudButton>
            </MudCardActions>
        </MudCard>
    </MudItem>
</MudGrid>

<MudDialog @ref="@MudDialog" Style="width: 100%">
    <DialogContent>
        <MudList T="string" Dense="true">
            <MudListItem Icon="@IconsFA.Solid.Icon("check").Font" Style="text-align: justify;">
                The photo taken by your camera will be kept private (it will not be accessible within the platform) for future verification, if necessary.
            </MudListItem>
            <MudListItem Icon="@IconsFA.Solid.Icon("check").Font" Style="text-align: justify;">
                The data resulting from this validation (attributes of your face) will not be kept on our servers and will only exist during the detection process.
            </MudListItem>
        </MudList>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@(async () => { await MudDialog!.CloseAsync(); })">
            @Button.Close
        </MudButton>
    </DialogActions>
</MudDialog>

<FloatingButton Template="Template.Back"></FloatingButton>

@code
{
    private ValidationModel? Validation { get; set; }
    private MudDialog? MudDialog { get; set; }
    private byte[] Picture { get; set; } = [];

    private MediaDevices? mediaDevices = default;
    private MediaStreamTrack? videoStreamTrack;
    private ElementReference videoElement;
    private readonly List<(string label, string id)> Cameras = new();
    private string? currentCameraId;

    protected override async Task LoadAuthDataAsync()
    {
        Validation = await ValidationApi.Get();
    }

    protected async Task TakeShot()
    {
        try
        {
            var data = await JsRuntime.InvokeAsync<string>("captureFrame", videoElement);
            data = data[(data.IndexOf(',') + 1)..]; // Remove the suffix added by javascript
            Picture = Convert.FromBase64String(data);

            await StopVideoTrack();

            Validation ??= new ValidationModel();
        }
        catch (Exception ex)
        {
            await ProcessException(ex);
        }
    }

    protected async Task Reset()
    {
        try
        {
            Picture = [];
            await OpenVideo();
        }
        catch (Exception ex)
        {
            await ProcessException(ex);
        }
    }

    protected async Task SendPhoto()
    {
        try
        {
            AppStateStatic.ProcessingStarted?.Invoke();
            Validation = await ValidationApi.UploadPhotoValidation(Picture);
            AppStateStatic.ProcessingFinished?.Invoke();

            await ShowSuccess("Photo validated successfully!");
            await JsRuntime.Window().HistoryBack();
        }
        catch (Exception ex)
        {
            await ProcessException(ex);
        }
    }

    async Task OpenVideo()
    {
        try
        {
            if (mediaDevices is null)
                mediaDevices = await MediaDevicesService.GetMediaDevicesAsync();

            await SelectDevice(null);
            var deviceInfos = await mediaDevices.EnumerateDevicesAsync();
            Cameras.Clear();
            foreach (var device in deviceInfos)
            {
                if (await device.GetKindAsync() is MediaDeviceKind.VideoInput)
                {
                    Cameras.Add((await device.GetLabelAsync(), await device.GetDeviceIdAsync()));
                }
            }

            currentCameraId = Cameras.FirstOrDefault().id;
        }
        catch (WebIDLException ex)
        {
            await ProcessException(new Exception($"{ex.GetType().Name}: {ex.Message}"));
            await StopVideoTrack();
        }
        catch (Exception ex)
        {
            await ProcessException(ex);
            await StopVideoTrack();
        }
    }

    async Task SelectDevice(string? newCameraId)
    {
        if (currentCameraId != null && newCameraId == currentCameraId)
            return; // They picked the same device

        var mediaTrackConstraints = new MediaTrackConstraints();
        if (currentCameraId is not null)
        {
            mediaTrackConstraints.DeviceId = new ConstrainDOMStringParameters() { Exact = currentCameraId };
        }

        await using var mediaStream = await mediaDevices!.GetUserMediaAsync(new MediaStreamConstraints() { Video = mediaTrackConstraints });
        var videoTracks = await mediaStream.GetVideoTracksAsync();
        videoStreamTrack = videoTracks.FirstOrDefault();
        foreach (var unusedTrack in videoTracks.Skip(1))
        {
            await unusedTrack.DisposeAsync();
        }
        if (videoStreamTrack is not null)
        {
            var capabilities = await videoStreamTrack.GetCapabilitiesAsync();
            currentCameraId = capabilities.DeviceId;
        }

        StateHasChanged();

        // We don't have a wrapper for HtmlMediaElement's yet so we use simple JSInterop for this part.
        await using var htmlMediaElement = await JsRuntime.InvokeAsync<IJSObjectReference>("getReference", videoElement);
        await JsRuntime.InvokeVoidAsync("setAttribute", htmlMediaElement, "srcObject", mediaStream.JSReference);
    }

    async Task StopVideoTrack()
    {
        if (videoStreamTrack is not null)
        {
            await videoStreamTrack.StopAsync();
        }
        videoStreamTrack = null;
        if (mediaDevices is not null)
            await mediaDevices.DisposeAsync();
        mediaDevices = null;
        currentCameraId = null;
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();
        await StopVideoTrack();
    }
}